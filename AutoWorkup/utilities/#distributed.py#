from __future__ import division
from past.utils import old_div
import math

def load_cluster(modules=[]):
    if len(modules) > 0:
        module_list = []
        for module in modules:
            module_list.append("module load {name}".format(name=module))
        assert len(modules) == len(module_list)
        return '\n'.join(module_list)
    return ''


def source_virtualenv(virtualenv_dir=''):
    if virtualenv_dir is None:
        return ''
    assert virtualenv_dir != ''
    return "source {0}".format(virtualenv_dir)


def prepend_env(environment={}):
    import os
    export_list = []
    for key, value in list(environment.items()):
        export_list.append("export {key}={value}{sep}${key}".format(key=key, value=value, sep=os.pathsep))  # Append to variable
    return '\n'.join(export_list)


def create_global_sge_script(cluster, environment):
    """
    This is a wrapper script for running commands on an SGE cluster
    so that all the python modules and commands are pathed properly

    >>> import os
    >>> nomodules = open(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'TestSuite', 'node.sh.template.nomodules'), 'r')
    >>> create_global_sge_script({'modules':[]}, {'virtualenv_dir':'/path/to/virtualenv_dir', 'env': os.environ}).split('\n')[0]
    True
    >>> create_global_sge_script({'modules':[]}, {'virtualenv_dir':'/path/to/virtualenv_dir', 'env': os.environ}).split('\n')[0] == '#!/bin/bash FAIL'

    """
    import os
    from string import Template
    import sys

    sub_dict = dict(LOAD_MODULES=load_cluster(cluster['modules']),
                    VIRTUALENV_DIR=source_virtualenv(environment['virtualenv_dir']),
                    EXPORT_ENV=prepend_env(environment['env']))
    with open(os.path.join(os.path.dirname(__file__), 'node.sh.template')) as fid:
        tpl = fid.read()
    retval = Template(tpl).substitute(sub_dict)
    return retval


    -S /bin/bash -cwd -pe smp 5 -l mem_free=2G -o /dev/null -e /dev/null test FAIL
    >>> modify_qsub_args('test', 2, 5, -1 )
    -S /bin/bash -cwd -pe smp 5- -l mem_free=2G -o /dev/null -e /dev/null test FAIL
    >>> modify_qsub_args('test', 8, 5, 7)
    -S /bin/bash -cwd -pe smp 5-7 -l mem_free=8G -o /dev/null -e /dev/null test FAIL
    >>> modify_qsub_args('test', 8, 5, 7, -1)
    -S /bin/bash -cwd -pe smp 5-7 -l mem_free=8G -o /dev/null -e /dev/null test FAIL
    >>> modify_qsub_args('test', 1, 5, 7, stdout='/my/path', stderr='/my/error')
    -S /bin/bash -cwd -pe smp 5-7 -l mem_free=1G -o /my/path -e /my/error test FAIL

    """
    assert memoryGB <= 48 , "Memory must be supplied in GB, so anything more than 24 seems not-useful now."

    ## NOTE: At least 1 thread needs to be requested per 2GB needed
    memoryThreads = int(math.ceil((old_div(math.ceil(memoryGB),2)))) #Ensure that threads are integers
    minThreads = max(minThreads, memoryThreads)
    maxThreads = max(maxThreads, memoryThreads)
    maxThreads=int(maxThreads) # Ensure that threads are integers
    minThreads=int(minThreads) # Ensure that threads are integers

    if maxThreads is None or minThreads == maxThreads:
       threadsRangeString =  '{0}'.format(minThreads)
       maxThreads = minThreads
    elif maxThreads == -1:
       threadsRangeString= '{0}-'.format(minThreasds)
       maxThreads = 12345 #HUGE NUMBER!
    else:
       threadsRangeString= "{0}-{1}".format(minThreads,maxThreads)

    if maxThreads < minThreads:
       assert  maxThreads > minThreads, "Must specify maxThreads({0}) > minThreads({1})".format(minThreads,maxThreads)

    ## TODO:  May need to figure out how to set memory and threads for cluster.
    ## for now just let the number of threads requested take care of this because
    ## the job manager on helium is really slow with lots of constraints
    ##  -l mem_free={mem}

    ## format_str = '-S /bin/bash -cwd -pe smp {mint}{maxt} -o {stdout} -e {stderr} {queue}'
    format_str = '-S /bin/bash -cwd -pe smp {totalThreads} -o {stdout} -e {stderr} {queue}'.format(
                 mint=minThreads, maxt=threadsRangeString,
                 totalThreads=threadsRangeString,
                 mem=memoryGB,
                 stdout=stdout, stderr=stderr, queue=queue)
    return format_str
